#ifndef COQUI_THC_RPA_ICC
#define COQUI_THC_RPA_ICC

#include "mpi3/communicator.hpp"
#include "nda/nda.hpp"
#include "nda/blas.hpp"
#include "numerics/shared_array/nda.hpp"
#include "numerics/distributed_array/nda.hpp"
#include "numerics/nda_functions.hpp"

#include "IO/app_loggers.h"
#include "utilities/Timer.hpp"

#include "mean_field/MF.hpp"
#include "methods/ERI/detail/concepts.hpp"
#include "methods/HF/thc_solver_comm.hpp"

namespace methods {
  namespace solvers {

    double gw_t::thc_rpa_Xqindep(const nda::MemoryArrayOfRank<5> auto &G_tskij,
                                      THC_ERI auto &thc) {
      /** setup processor grids and block sizes for various intermediate objects **/

      auto MF = thc.MF();
      auto mpi = thc.mpi();

      // pgrid for Pi_wPQ: maximize nqpools: a) nqpts_ibz= i * b; b) np = i * bb
      // not sure if this is the optimal configuration
      int np = mpi->comm.size();
      int nqpts_ibz = MF->nqpts_ibz();
      long nw_half = (_ft->nw_b()%2==0)? _ft->nw_b()/2 : _ft->nw_b()/2 + 1;
      long NP = thc.Np();
      utils::check(G_tskij.shape()==
                   std::array<long,5>{_ft->nt_f(),MF->nspin(),MF->nkpts_ibz(),MF->nbnd(),MF->nbnd()},
                   "gw_t::thc_rpa_Xqindep: G_tskij Shape mismatch");

      // for Pi_wqPQ
      std::array<long, 4> w_pgrid = {}; // (w, q, P, Q)
      std::array<long, 4> w_bsize = {};
      {
        long nqpools = utils::find_proc_grid_max_npools(np, nqpts_ibz, 0.2);
        np /= nqpools;
        long nwpools = utils::find_proc_grid_max_npools(np, nw_half, 0.2);
        np /= nwpools;
        long np_P = utils::find_proc_grid_min_diff(np, 1, 1);
        long np_Q = np / np_P;
        utils::check(nqpools > 0 and nqpools <= nqpts_ibz,
                     "gw_t:: nqpools <= 0 or nqpools > nqpts_ibz. nqpools = {}", nqpools);
        utils::check(nqpools > 0 and nwpools <= nw_half,
                     "gw_t:: nwpools <= 0 or nwpools > nw_half. nwpools = {}", nwpools);
        utils::check(mpi->comm.size() % nqpools == 0, "gw_t:: gcomm.size() % nqpools != 0");
        utils::check(mpi->comm.size() % (nqpools * nwpools) == 0, "gw_t:: gcomm.size() & (nqpools*nwpools) != 0");


        w_pgrid = {nwpools, nqpools, np_P, np_Q}; // (w, q, P, Q)

        // Setup square block size: make sure block sizes produce at least one full block per task
        w_bsize = {1, 1, 1, 1};
        w_bsize[2] = std::min( {(long)1024, NP/w_pgrid[2], NP/w_pgrid[3]});
        w_bsize[3] = w_bsize[2];
      }

      scr_coulomb_t scr_eri(_ft, "rpa", _div_treatment);
      auto dPi_tqPQ = scr_eri.eval_Pi_qdep(G_tskij, thc);
      bool reset_Pi_t = true;
      auto dPi_wqPQ = scr_eri.tau_to_w(dPi_tqPQ, w_pgrid, w_bsize, reset_Pi_t);
      return thc_rpa_energy_all_impl(dPi_wqPQ, thc);
    }

    template<nda::MemoryArrayOfRank<4> Array_w_t, typename communicator_t>
    double gw_t::thc_rpa_energy_all_impl(memory::darray_t<Array_w_t, communicator_t> &dPi_wqPQ,
                                         THC_ERI auto &thc) {
      _Timer.start("EVALUATE_RPA");
      auto mpi = thc.mpi();
      auto [gnw_half, nqpts, NP, NQ] = dPi_wqPQ.global_shape();
      auto [nw_loc, nq_loc, NP_loc, NQ_loc] = dPi_wqPQ.local_shape();
      auto [w_origin, q_origin, P_origin, Q_origin] = dPi_wqPQ.origin();
      long nq_loc_max = nq_loc;
      dPi_wqPQ.communicator()->broadcast_n(&nq_loc_max, 1, 0);

      auto P_rng = dPi_wqPQ.local_range(2);
      auto Q_rng = dPi_wqPQ.local_range(3);

      auto pgrid = dPi_wqPQ.grid();
      auto block_size = dPi_wqPQ.block_size();
      long qpool_id = (nq_loc==nq_loc_max)? q_origin/nq_loc : (q_origin-nqpts%pgrid[1])/nq_loc;

      app_log(2, "e_rpa_impl:");
      app_log(2, "  - processor grid for Pi: (w, q, P, Q) = ({}, {}, {}, {})", pgrid[0], pgrid[1], pgrid[2], pgrid[3]);
      app_log(2, "  - block size: (w, q, P, Q) = ({}, {}, {}, {})", block_size[0], block_size[1], block_size[2], block_size[3]);

      _Timer.start("RPA_ALLOC");
      nda::array<ComplexType, 1> e_rpa(1);
      nda::array<ComplexType, 2> e_rpa_w(_ft->nw_b(), 1);
      nda::array<ComplexType, 2> e_rpa_t(_ft->nt_b(), 1);
      _Timer.stop("RPA_ALLOC");

      // Setup wq_intra_comm
      mpi3::communicator wq_intra_comm = mpi->comm.split(w_origin*nqpts + q_origin, mpi->comm.rank());
      utils::check(wq_intra_comm.size() == pgrid[2]*pgrid[3], "wq_intra_comm.size() != pgrid[2]*pgrid[3]");
      // Setup q_intra_comm
      mpi3::communicator q_intra_comm = mpi->comm.split(q_origin, mpi->comm.rank());
      utils::check(q_intra_comm.size() == pgrid[0]*pgrid[2]*pgrid[3], "q_intra_comm.size() != pgrid[0]*pgrid[2]*pgrid[3]");


      using Array_2D_t = memory::array<HOST_MEMORY, ComplexType, 2>;
      using math::nda::make_distributed_array;
      auto dPi_PQ = make_distributed_array<Array_2D_t>(wq_intra_comm, {pgrid[2], pgrid[3]}, {NP, NQ}, {block_size[2], block_size[3]});
      auto dZ_PQ  = make_distributed_array<Array_2D_t>(wq_intra_comm, {pgrid[2], pgrid[3]}, {NP, NQ}, {block_size[2], block_size[3]});
      auto dA_PQ  = make_distributed_array<Array_2D_t>(wq_intra_comm, {pgrid[2], pgrid[3]}, {NP, NQ}, {block_size[2], block_size[3]});
      utils::check(dPi_PQ.local_range(0) == P_rng, "Error: local range mismatches!" );
      utils::check(dPi_PQ.local_range(1) == Q_rng, "Error: local range mismatches!");
      utils::check(dPi_PQ.local_shape()[0] == NP_loc and dPi_PQ.local_shape()[1] == NQ_loc,
                   "Error: local shape mismatched!");

      std::vector<std::pair<long,long> > diag_idx;
      for (long iP = 0; iP < NP_loc; ++iP) {
        long P = iP + P_origin;
        for (size_t iQ = 0; iQ < NQ_loc; ++iQ) {
          long Q = iQ + Q_origin;
          if (P == Q) diag_idx.push_back({iP, iQ});
        }
      }

      auto Pi_loc = dPi_wqPQ.local();
      auto Pi_PQ_loc = dPi_PQ.local();
      auto Z_PQ_loc = dZ_PQ.local();
      auto A_loc = dA_PQ.local();
      for (long iq_loc = 0; iq_loc < nq_loc; ++iq_loc) {
        long iq = q_origin + iq_loc;
        Z_PQ_loc = thc.Z(iq, P_rng, Q_rng, qpool_id, pgrid[1], q_intra_comm);
        long q_weight = std::count(thc.MF()->qp_to_ibz().begin(), thc.MF()->qp_to_ibz().end(),iq);

        for (long n = 0; n < nw_loc; ++n) {
          long wn = _ft->nw_b()/2 + w_origin + n;
          long mwn = _ft->nw_b()/2 - w_origin - n;
          Pi_PQ_loc = Pi_loc(n, iq_loc, nda::ellipsis{});

          // A = Pi(w) * Z
          math::nda::slate_ops::multiply(dPi_PQ, dZ_PQ, dA_PQ);

          for (auto idx: diag_idx) {
            e_rpa_w(wn, 0) += double(q_weight) * A_loc(idx.first, idx.second);
            if (mwn != wn) e_rpa_w(mwn, 0) += double(q_weight) * A_loc(idx.first, idx.second);
            A_loc(idx.first, idx.second) -= ComplexType(1.0);
          }
          A_loc *= -1.0; // A = I - A now

          // Tr{ln(B)} = ln(det(B))
          ComplexType det_A = math::nda::slate_ops::determinant(dA_PQ, diag_idx);
          if (det_A.real() < 0) {
            if (dA_PQ.communicator()->root())
              std::cout << "[WARNING] thc_rpa:: determinant of (I - Pi*Z) < 0. "
                           "This is likely due to our API of determinant from SLATE "
                           "which miscounts the number of pivoting..." << std::endl;
            det_A *= -1.0;
          }

          if (dA_PQ.communicator()->root()) {
            e_rpa_w(wn, 0) += double(q_weight) * std::log(det_A.real());
            if (mwn != wn) e_rpa_w(mwn, 0) += double(q_weight) * std::log(det_A.real());
          }
        }
      }
      // prevent dead block in thc.Z() in case nq_loc is not the same for all processors
      for (long iq_loc = nq_loc; iq_loc < nq_loc_max; ++iq_loc)
        Z_PQ_loc = thc.Z(0, P_rng, Q_rng, qpool_id, pgrid[1], q_intra_comm);

      dPi_wqPQ.communicator()->all_reduce_in_place_n(e_rpa_w.data(), e_rpa_w.size(), std::plus<>{});
      _ft->w_to_tau(e_rpa_w, e_rpa_t, imag_axes_ft::boson);
      _ft->tau_to_beta(e_rpa_t, e_rpa);
      e_rpa /= (2.0 * thc.MF()->nkpts());
      if (e_rpa(0).imag()/e_rpa(0).real() >= 1e-10) {
        app_log(2, "** Warning **: e_rpa.imag()/e_rpa.real() = {}, e_rpa.real() = {}, e_rpa.imag() = {}",
                e_rpa(0).imag()/e_rpa(0).real(), e_rpa(0).real(), e_rpa(0).imag());
      }
      _Timer.stop("EVALUATE_RPA");

      return e_rpa(0).real();
    }
  }
}

#endif //COQUI_THC_RPA_ICC
