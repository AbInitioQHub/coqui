#include "mpi3/communicator.hpp"
#include "nda/nda.hpp"
#include "nda/blas.hpp"
#include "numerics/nda_functions.hpp"
#include "utilities/proc_grid_partition.hpp"

#include "mean_field/MF.hpp"
#include "methods/ERI/detail/concepts.hpp"

namespace methods {
  namespace solvers {
    template<nda::MemoryArray AF_t>
    void hf_t::add_J(sArray_t<AF_t> &sF_skij, const nda::MemoryArrayOfRank<4> auto &Dm_skij, 
                     Cholesky_ERI auto &&chol) {
      decltype(nda::range::all) all;

      auto MF = chol.MF();
      auto mpi = chol.mpi();

      auto [ns, nkpts, nbnd, nbnd2] = Dm_skij.shape();
      auto Np = chol.Np();
      utils::check(MF->npol()==1, "Non-collinear calculations not yet implemented.");

      auto sJ_skij = math::shm::make_shared_array<AF_t>(*mpi, {ns, nkpts, nbnd, nbnd});
      sJ_skij.set_zero();

      nda::array<ComplexType, 1> X_Q(Np);
      if (nkpts != 1) {
        nda::array<ComplexType, 3> V_Qij_conj(Np, nbnd, nbnd);
        auto V_2D_conj = nda::reshape(V_Qij_conj, shape_t<2>{Np, nbnd*nbnd});
        for (size_t is = 0; is < ns; ++is) {
          for (size_t ik =0; ik < nkpts; ++ik) {
            V_Qij_conj = nda::conj(chol.V(0, is, ik));
            auto Dm_ij_1D = nda::reshape(Dm_skij(is,ik,all,all), shape_t<1>{nbnd*nbnd});
            // X_Q += conj(V_Qij) * Dmsk_ij
            nda::blas::gemv(ComplexType(1.0), V_2D_conj, Dm_ij_1D, ComplexType(1.0), X_Q);
          }
        }
      } else { // molecular case
        auto sV_Qij_conj = math::shm::make_shared_array<nda::array<ComplexType, 3> >(
            *mpi, {Np, nbnd, nbnd});
        auto V_2D_conj = nda::reshape(sV_Qij_conj.local(), shape_t<2>{Np, nbnd*nbnd});
        for (size_t is = 0; is < ns; ++is) {
          for (size_t ik =0; ik < nkpts; ++ik) {
            sV_Qij_conj.win().fence();
            if(mpi->node_comm.rank() == 0) {
              sV_Qij_conj.local() = nda::conj(chol.V(0, is, ik));
            }
            sV_Qij_conj.win().fence();
            auto Dm_ij_1D = nda::reshape(Dm_skij(is,ik,all,all), shape_t<1>{nbnd*nbnd});
            // X_Q += conj(V_Qij) * Dmsk_ij
            nda::blas::gemv(ComplexType(1.0), V_2D_conj, Dm_ij_1D, ComplexType(1.0), X_Q);
          }
        }
      }

      double prefactor = (ns == 1)? 2.0/nkpts : 1.0/nkpts; // 2.0 comes from spin sum
      X_Q *= prefactor;

      int rank = sJ_skij.communicator()->rank();
      int size = sJ_skij.communicator()->size();

      auto J_skij = sJ_skij.local();
      if(nkpts != 1) {
          sJ_skij.win().fence();
          for (size_t isk = rank; isk < ns*nkpts; isk+=size) {
            size_t is = isk / nkpts;
            size_t ik = isk % nkpts;
            // Fsk_ij = X(Q) * V(Q, ij)
            auto V_Qij = chol.V(0, is, ik); // iq=0, is=is, ik=ik
            auto V_Q_ij_2D = nda::reshape(V_Qij, shape_t<2>{Np, nbnd*nbnd});
            auto Jsk_ij_1D = nda::reshape(J_skij(is, ik, all, all), shape_t<1>{nbnd*nbnd});
            nda::blas::gemv(nda::transpose(V_Q_ij_2D), X_Q, Jsk_ij_1D);
          }
          sJ_skij.win().fence();
          sJ_skij.all_reduce();
      }
      else { // molecular case
             // TODO PP: parallelize it! A weird nda contiguous bug prevents that...
          auto sV_Qij = math::shm::make_shared_array<nda::array<ComplexType, 3> >(
              *mpi, {Np, nbnd, nbnd});
          size_t ik = 0;
          nda::array_view<ComplexType, 3> V_Qij = sV_Qij.local();
          sJ_skij.win().fence();
          for (size_t is = 0; is < ns; ++is) {
              sV_Qij.win().fence();
              if(mpi->node_comm.rank() == 0) {
                  V_Qij = make_regular(chol.V(0, is, ik)); // iq=0, ik=0 for molecules
              }
              sV_Qij.win().fence();
              // Fsk_ij = X(Q) * V(Q, ij)
              if(mpi->comm.size() == 0 && rank == 0) { // serial case
                auto V_Q_ij_2D = nda::reshape(V_Qij, shape_t<2>{Np, nbnd*nbnd});
                auto Jsk_1_ij_2D = nda::reshape(J_skij(is, ik, all, all), shape_t<2>{1, nbnd*nbnd});
                auto X_1Q_2D = nda::reshape(X_Q, shape_t<2>{1, Np});
                nda::blas::gemm(X_1Q_2D, V_Q_ij_2D, Jsk_1_ij_2D);
              }
              else { // parallel case proceeds with caution due to nda contigeous bug
                auto V_Q_ij_2D = nda::reshape(V_Qij, shape_t<2>{Np, nbnd*nbnd});
                auto Jsk_1_ij_2D = nda::reshape(J_skij(is, ik, all, all), shape_t<2>{1, nbnd*nbnd});
                auto X_1Q_2D = nda::reshape(X_Q, shape_t<2>{1, Np});

                // Rounded batch size
                size_t batch_size = (nbnd*nbnd) / mpi->comm.size();
                size_t ij_start = rank*batch_size;
                // end of range for the rounded batch and for the last batch
                size_t ij_end = (rank != mpi->comm.size()-1) ? (rank+1)*batch_size : nbnd*nbnd;
                nda::range ij_range(ij_start, ij_end);

                // Copy is necessary due to an nda bug
                auto V_Q_ijranged_2D = nda::make_regular(V_Q_ij_2D(all, ij_range));
                auto Jsk_1_ijranged_2D = nda::make_regular(Jsk_1_ij_2D(all, ij_range));
                nda::blas::gemm(X_1Q_2D, V_Q_ijranged_2D, Jsk_1_ijranged_2D);

                // Write the result into the right place in shared memory
                Jsk_1_ij_2D(all, ij_range) = Jsk_1_ijranged_2D(all, all);

              }
          }
          sJ_skij.win().fence();
          sJ_skij.all_reduce();
      }

      if (sF_skij.node_comm()->root())
        sF_skij.local() += sJ_skij.local();
      sF_skij.communicator()->barrier();
    }

    template<nda::MemoryArray AF_t>
    auto hf_t::add_K(sArray_t<AF_t> &sF_skij, const nda::MemoryArrayOfRank<4> auto &Dm_skij, 
                    Cholesky_ERI auto &&chol, const nda::MemoryArrayOfRank<4> auto &S_skij) {
      decltype(nda::range::all) all;

      auto MF = chol.MF();
      auto mpi = chol.mpi();

      auto [ns, nkpts, nbnd, nbnd2] = Dm_skij.shape();
      auto Np = chol.Np();
      utils::check(MF->npol()==1, "Non-collinear calculations not yet implemented.");

      auto comm = sF_skij.communicator();
      auto[dim0_rank, dim0_comm_size, dim1_rank, dim1_comm_size] = utils::setup_two_layer_mpi(comm, nkpts, nbnd);
      if(nkpts == 1) {
          std::swap(dim0_rank, dim1_rank);
          std::swap(dim0_comm_size, dim1_comm_size);
      }
      app_log(2, "    - MPI processors along q axis = {}", dim0_comm_size);
      app_log(2, "    - MPI processors along nbnd axis = {}", dim1_comm_size);

      nda::array<ComplexType, 4> K_skij(ns, nkpts, nbnd, nbnd);

      long ikmq = -1;
      nda::matrix<ComplexType> Xki_Qb(Np, nbnd);
      nda::matrix<ComplexType> Vki_Qa(Np, nbnd);

      if(nkpts != 1) {
          nda::array<ComplexType, 3> Vtilde_kmq_k_conj(Np, nbnd, nbnd);
          
          for (size_t iq = dim0_rank; iq < nkpts; iq += dim0_comm_size) {
            for (size_t sk = 0; sk < ns*nkpts; ++sk) {
              size_t is = sk / nkpts;
              size_t ik = sk % nkpts;
              ikmq = MF->qk_to_k2(iq, ik); // K(ikmq) = K(ik) - Q(iq) + G
              Vtilde_kmq_k_conj = chol.V_kmq_k(iq, is, ik, true); // read or copy
              auto Dm_ab = Dm_skij(is, ikmq, all, all);
              for (size_t i = dim1_rank; i < nbnd; i += dim1_comm_size) {
                // Xki_Qb = Vtilde_Qa * Dm_ab
                Vki_Qa = nda::make_regular(nda::conj(Vtilde_kmq_k_conj(all, all, i))); // copy
                nda::blas::gemm(Vki_Qa, Dm_ab, Xki_Qb);
          
                // Ki_j += Xki_Qb * Vtilde_Qb_j_conj
                auto V_Qb_j_2D = nda::reshape(Vtilde_kmq_k_conj, shape_t<2>{Np * nbnd, nbnd});
                auto Ki_1_j_2D = nda::matrix_view<ComplexType>({1, nbnd}, K_skij.data() + sk*nbnd*nbnd + i*nbnd);
                auto Xki_1_Qb_2D = nda::matrix_view<ComplexType>({1, Np*nbnd}, Xki_Qb.data());
                nda::blas::gemm(ComplexType(1.0), Xki_1_Qb_2D, V_Qb_j_2D, ComplexType(1.0), Ki_1_j_2D);
              }
            }
          }
      } else {
        auto Vtilde_kmq_k_conj = math::shm::make_shared_array<nda::array<ComplexType, 3> >(
            *mpi, {Np, nbnd, nbnd});
          
        for (size_t iq = dim0_rank; iq < nkpts; iq += dim0_comm_size) {
          for (size_t sk = 0; sk < ns*nkpts; ++sk) {
            size_t is = sk / nkpts;
            size_t ik = sk % nkpts;
            ikmq = MF->qk_to_k2(iq, ik); // K(ikmq) = K(ik) - Q(iq) + G
            Vtilde_kmq_k_conj.win().fence();
            if(mpi->node_comm.rank() == 0) {
              Vtilde_kmq_k_conj.local() = chol.V_kmq_k(iq, is, ik, true);
            }
            Vtilde_kmq_k_conj.win().fence();
            auto Dm_ab = Dm_skij(is, ikmq, all, all);
            for (size_t i = dim1_rank; i < nbnd; i += dim1_comm_size) {
              // Xki_Qb = Vtilde_Qa * Dm_ab
              Vki_Qa = nda::make_regular(nda::conj(Vtilde_kmq_k_conj.local()(all, all, i))); // copy
              nda::blas::gemm(Vki_Qa, Dm_ab, Xki_Qb);
          
              // Ki_j += Xki_Qb * Vtilde_Qb_j_conj
              auto V_Qb_j_2D = nda::reshape(Vtilde_kmq_k_conj.local(), shape_t<2>{Np * nbnd, nbnd});
              auto Ki_1_j_2D = nda::matrix_view<ComplexType>({1, nbnd}, K_skij.data() + sk*nbnd*nbnd + i*nbnd);
              auto Xki_1_Qb_2D = nda::matrix_view<ComplexType>({1, Np*nbnd}, Xki_Qb.data());
              nda::blas::gemm(ComplexType(1.0), Xki_1_Qb_2D, V_Qb_j_2D, ComplexType(1.0), Ki_1_j_2D);
            }
          }
        }
      }
      comm->all_reduce_in_place_n(K_skij.data(), K_skij.size(), std::plus<>{});
      K_skij *= (-1.0/nkpts);
      sF_skij.win().fence();
      if (sF_skij.node_comm()->root())
        sF_skij.local() += K_skij;
      sF_skij.win().fence();

      HF_K_correction(sF_skij, Dm_skij, S_skij, MF->madelung());
      sF_skij.communicator()->barrier();
    }
  } // solvers
} // methods
